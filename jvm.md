# jvm

## 运行时数据
1. 执行引擎->本地库接口->本地方法库
2. 方法区-(Method Area)
   1. 有哪些类型
      1. 类信息
      2. 常量
      3. 静态变量
      4. 即时编译器(jit)后的产物
      5. 运行时常量池-类加载后,1.7开始存储在堆中
         1. 字面量
         2. 符号引用
         3. 直接引用
         4. 动态存入-如String.intern()
   2. 直接内存-Direct Memory-不属于堆内存
      1. NIO类中-直接使用native方法分配堆外空间
      2. 被堆中的DirectByteBuffer对象引用-也会被GC管理到
      3. 避免在jvm堆与native内存(用户态和内核态)之间来回复制数据
   3. 永久代
      1. 方法区是一种JVM虚拟机规范约定的概念,主要是存储类的元数据
      2. 永久代-Permanent Generation-HotSpot在JDK7以及之前的方法区实现,维护在JVM内存中,容易超出限制
      3. 元空间-Metaspace-HotSpot在JDK8以及之后的方法区实现,维护在本地内存中
3. 堆-(Java Heap)
   1. 新生代
      1. Eden空间
         1. 新创建对象的主要分配区域
         2. 当Eden空间满时,会触发一次Minor GC
         3. 存活下来的对象会存储在survivor区域内
         4. TLAB
            1. 线程本地分配缓冲区,是Eden区域下的一个小空间,每个线程都会有
            2. 减少多线程情况下,在堆内存上分配对象的竞争，提高对象分配的效率
            3. 当一个线程需要为对象分配空间时,会先在TLAB空间中尝试,如果满足不了,才在Eden中分配
      2. from survivor与to survivor
         1. 用于保存经过一次或多次Minor GC后还存活的对象
         2. 在2个survivor之间互相移动
         3. 整体流程,Minor GC时将Eden和from survivor中存活的对象复制到to survivor中
         4. 每经过一次Minor GC,阈值会增加,一般达到15次时,移动到老年代
   2. 老年代
      1. 大对象直接分配到老年代中-长字符串/数组
      2. 长期存活的对象进入老年代
   3. 采用分代收集算法
   4. 动态对象年龄判定
      1. 一般来说,Minor GC后,一个对象如果age达到15(默认),则进入老年代
      2. 如果Minor GC后,Survivor内相同age的对象超过整个survivor空间的一半,则直接进入老年代,无需等待age达到
   5. 空间分配担保
      1. 发生Minor GC时,会检查老年代的剩余连续空间是否大于新生代所有对象的空间大小
   6. 内存结构
      1. 对象的大小是8个字节的整数倍
      2. 对象是1个或2个的8个字节
      3. 对象头
         1. mark word-synchronize的锁升级体现在这
            1. 未锁定
               1. 对象hash+对象分代年龄+是否偏向锁+标识位
            2. 可偏向
               1. 偏向线程id+偏向时间戳+是否偏向锁+标识位
            3. 轻量级锁
               1. 指向栈中锁记录的指针+标识位
            4. 重量级锁定(膨胀) 
               1. 指向重量级锁(互斥锁)的指针+标识位
            5. GC标识
               1. 空+标识位
         2. class对象指针
         3. 数组长度-如果是数组
      4. 实际的对象数据
      5. 填充位
4. 虚拟机栈
   1. 多个栈针-每个代表一个方法调用(入栈)和方法执行完成(出栈)
   2. 局部变量表-存放方法参数和方法内定义的局部变量
      1. 基本数据类型-boolean,byte,char,int,float,long,double
      2. 对象引用-对象起始地址的引用指针
      3. returnAdress-指向了一个字节码指令的地址
   3. 操作数栈-指令所操作的数据与结果的存放地
      1. 句柄访问-栈中存储的reference地址稳定
         1. 到对象实例数据的指针-堆中
            1. 对象实例数据-堆中
         2. 到对象类型数据的指针-堆中
            1. 对象类型数据-方法区
      2. 直接引用-速度更快(HotSpot采用此种)
         1. 对象实例数据-包含到对象类型数据的指针-堆中
            1. 对象类型数据-方法区
   4. 动态链接-运行时的符号引用转为直接引用
   5. 方法出口-往往是上个栈帧的程序计数器地址
5. 本地方法栈
   1. 支持本地方法的执行,存储本地方法的调用状态
   2. JVM为执行本地方法(Native Methods)提供的内存区域.本地方法通常是用C/C++等非Java语言编写的方法
6. 程序计数器
   1. 记录当前线程的执行位置
   2. 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器
   3. 每个线程都有一个独立的程序计数器,各线程之间的计数器互不影响

## GC
1. GC Roots
   1. 用于确定对象存活状态的起始点,GC算法的起点
   2. 从GC Roots出发,进行可达性分析.不可达的则认为可以进行GC
   3. 分布
      1. 虚拟机栈(栈针中的本地变量表)中引用的对象
      2. 方法区中类静态属性引用的对象
      3. 方法区中常量引用的对象
      4. 本地方法栈中JNI(Native)引用的对象
2. 引用-什么时候要GC-引用等级
   1. 强-强引用-gcRoots可达就不回收-常规对象引用
   2. 软-软引用-softReference-即将内存溢出前回收-内存敏感的缓存
   3. 弱-弱引用-weakReference-下一次GC时回收-缓存
   4. 虚-虚引用-phantomReference-不影响对象生命周期，用于跟踪回收状态-对象回收通知
3. GC回收
   1. 算法
      1. 标记-清除-Mark-Sweep-空闲列表
      2. 复制-Copying-指针碰撞
      3. 标记-整理-Mark-Compact-指针碰撞
   2. OopMap（Ordinary Object Pointer Map）
      1. 是一种优化垃圾回收的机制,提供了对象引用的精确定位
      2. 生成-在JIT编译字节码文件时,会在安全点生成OopMap-并记录有哪些对象引用
      3. 使用-在GC时,JVM会查询OopMap,确定哪些位置是对象引用
   3. 安全点-Safe Point
      1. 程序中可以安全地暂停执行以进行垃圾收集的点-方法调用,循环跳转,异常跳转的地方
      2. JVM执行GC时,发起GC标识为真,线程进入安全点后会检查GC标识是否为真
      3. 如果是真,则会暂停线程,等所有线程都暂停后,进行GC
      4. GC完成后,线程结束暂停
   4. 安全区-Safe Region
      1. 安全点的扩展
      2. 是一段代码区域,在这个区域内,线程不会影响GC Roots的判断,可以安全的继续执行,而不用暂停,同时不会影响GC判断
         1. 进入安全区的线程,会有一个标识.GC会忽略有这个标识的线程
         2. 离开安全区时,需要检查GC Roots判断是否结束.否则,需要进行等待
      3. 解决那些在运行状态下无法快速到达安全点的线程-阻塞在I/O操作或等待锁-等待外部I/O等
   5. finalize()
      1. 不建议在代码中主动调用
      2. GC在确认一个对象不再使用,进行GC前会进行一次调用-所以不用主动调用
      3. 只会被调用1次
      4. 不可预测性-由JVM完成,预计完成时间不可控
      5. 性能开销-需要GC额外处理
      6. 替代方案-JDK7引入try-with-resources,确保资源更好释放
   6. 方法区回收
      1. 废弃的常量-没有再被引用
         1. 常量,类(接口),方法,字段的符号引用
      2. 无用的类
         1. 该类的所有实例都已经回收(在堆中不存在该类的实例)
         2. 加载该类的classLoader已经被回收
         3. 该类对应的class对象没有被其他地方引用,无法通过反射再获取该类
4. GC回收算法实现
   1. 新生代
      1. Serial-复制-单线程
      2. ParNew-复制-多线程
      3. Parallel Scavenge-复制-多线程-高吞吐量-1.8默认
      4. G1-复制(从2个region看)-多线程-更短的回收间隔-可预测的停顿时间-将堆拆成多个分区-优先回收垃圾最多的分区-1.9默认
   2. 老年代
      1. CMS-标记-清除-空闲列表-多线程-更短的停顿时间-1.9淘汰
      2. Serial Old-标记-整理-指针碰撞-单线程
      3. Parallel Old-标记-整理-指针碰撞-多线程-高吞吐量-1.8默认
      4. G1-1.9默认
   3. ZGC-适合大内存-并发处理能力强-着色指针-读屏障-1.11推出
   4. 详细case
      1. CMS
         1. 初始标出-找出GC Roots-stop the world
         2. 并发标记,可达性分析
         3. 重新标记-将并发标记的内容进行合并,得到最终标记-stop the world
         4. 并发回收
         5. 优点: 并发标记,停顿时间短,GC时延短
         6. 缺点
            1. 对CPU数量敏感
            2. 无法处理浮动垃圾-cms允许用户线程并行,需要在下一次GC时清除
            3. 标记-清除机制导致GC后有大量的碎片空间
            4. 可能出现Concurrent Mode Failure,则会使用Serial Old再进行一次full GC-需要较长时间
      2. G1
         1. 初始标出-找出GC Roots,并标记出可以让用户使用的region-stop the world
         2. 并发标记,可达性分析
         3. 重新标记-将并发标记的内容进行合并,得到最终标记-stop the world
         4. 筛选回收-选出性价比最高(成本/价值)的region回收-stop the world
         5. 优点
            1. 并行与并发
            2. 分代收集
            3. 空间整合
            4. 可预测的停顿
            5. region之间的对象引用以及新生代和老年代的对象引用使用remembered set,避免全推扫描

## 类
1. 类的加载机制
   1. 虚拟机将描述类的class文件加载到内存中,经过校验,转换解析,初始化,最终生成可以被虚拟机使用java文件
   2. java类的解析,连接,初始化都是在程序运行时期完成的->运行时动态加载和动态连接->java语言动态扩展机制
   3. 虚方法表
      1. 是java实现多态化的核心机制,通过存储方法的地址,支持运行时动态绑定
      2. 每个类加载时,都会创建一个表
      3. 包含这个类的所有方法,也包含父类的
      4. 如果子类重新了父类,则用子类的
      5. 后续查询方法直接查询该表
      6. 非静态方法才存在虚方法表
      7. 存储-对象头中的class元数据包含了虚方法表的地址
2. 类的生命周期
   1. 加载-加载字节流到jvm
   2. 连接-Linking
      1. 验证-检查字节码文件的合法性
      2. 准备-为类分配空间,初始化类字段为零值
      3. 解析-将常量池中的符号引用替换为直接引用
   3. 初始化-执行cliinit方法
   4. 使用
   5. 卸载
   6. 这些过程都是交叉混合式进行,在前一个步骤中激活下一个步骤
   7. 解析可能在初始化之后
3. 类的初始化时机
   1. 主动引用
      1. 第一次运行new,获取静态变量,设置静态变量,调用静态方法时
      2. 通过反射加载类时
      3. 初始化子类时初始化父类
      4. 虚拟机启动时会先初始化main()函数的类
      5. 调用invoke.MethodHandle解析的方法句柄未初始化时
         1. 类似于反射,但更高效的调用
   2. 被动引用
      1. 通过子类引用父类的静态常量,不会出发子类的初始化
      2. 通过数组定义来引用类,不会触发初始化
      3. 用final修饰的常量在编译期间会写入调用类的常量池,本质上并没有直接引用定义常量的类,所以不会初始化定义常量的类
4. 双亲委派模型
   1. 从父->子
      1. 启动类加载器-c++加载器,虚拟机的一部分,如加载rt.jar等虚拟机指定的类
      2. 扩展类加载器-java加载器,加载java_home/lib/ext下或用户指定的类
      3. 应用程序类加载器-java加载器,加载用户编写的类
      4. 自定义类加载器
         1. tomcat的多war包可以实现classLoader隔离-不同功能的类加载器作用于不同目录
         2. osgi的Bundle替换
   2. 每个类加载器都有独立的类命名空间
   3. 对于任意一个类,都需要通过它本身和对应的类加载器来确定在jvm中的唯一性
   4. 双亲委派模型
      1. 委托给父类加载器
         1. 首先会检查自身是否已经加载过,如果没有,则委托父类加载器
      2. 递归向上传递-直到抵达启动类加载器
      3. 如果父类加载器加载不了-搜索不到,才使用子类加载器
   5. 原因
      1. 避免重复加载-每个类只会被加载一次
      2. 保证核心类库的安全-核心类只能被启动类加载器加载,防止用户自定义的类替换核心类
      3. 类的唯一性-如果存在多个同名的类,但使用不同的类加载器,则无法确定类在jvm中的唯一性
      4. 同一个类被不同的类加载器加载,则像instanceof方法则无法使用

## 内存模型
1. 硬件层面
   1. 处理器-高速缓存-缓存一致性协议-主内存
   2. 基于高速缓存的存储交互解决了处理器与内存的速度矛盾(遵循MESI等,达到缓存一致性)
   3. 为了充分利用cpu内部的运算单元,处理器会执行指令乱序优化
2. JVM层面
   1. java线程-工作内存(虚拟机栈的部分区域,特定的寄存器和cpu的高速缓存)-store和load-主内存(对应堆中的对象实例数据部分)
   2. jvm的即时编译的指令重排序-硬件层面-将指令不按书写顺序发生给不同的电路处理单元
   3. 具有高效和跨平台的特点
   4. java内存模型的设计方式与特性(重排序)与遵守的原则都是为了在不改变运算结果的前提下,加快程序运行速度.
   5. 首先保证正确性,再去追求执行效率
      1. 每个volatile指令编译后新增一个StroreLoad屏障,为了避免后续有的volatile的读和写指令重排序
   6. 解决可见性与有序性问题
      1. volatile
         1. 是jvm中最轻量的同步机制
         2. 特性1:使用volatile修饰的变量对所有线程可见
            1. 大部分数据类型(32位)的单次操作是原子性的
            2. 但不保证复合操作上的原子性
            3. long double类型(64位),在部分平台上会拆分为2个32位,无法保证单子原子性,HotSpot特殊处理,可以保证单次的原子性,所以可以选择是否使用volatile来保证原子性
            4. 使用volatile修饰的变量,读总是会从主内存读,修改会马上刷新到主内存
         3. 特性2:禁止指令重排序优化
            1. java使用了线程内 as-if-serial-semantic的思想来提高程序的运行效率-即可以进行指令优化,但要保证单线程执行下结果一致
            2. 当我们不需要这种特性时,可以使用volatile赋值来禁止这个功能
         4. 内存语义
            1. volatile读-lock
            2. volatile写-unlock
            3. volatile读+volatile写=cas
      2. synchronize
         1. 可见性-代码块结束操作unlock的时候会将变量从工作内存刷新回主内存
      3. final
         1. 可见性-被final修饰的变量初始化后,对所有线程都可见
3. 遵循原则-先行发生原则-happens-before
   1. 判断数据是否存在竞争,线程是否安全的重要依据
   2. 是java内存模型中定义的两项操作之间的偏序关系
   3. 如果不符合原则,则可以进行指令重排序
   4. 内容
      1. 程序顺序规则-一个线程内,书写在前面的代码先行于后面书写的代码
      2. 线程start()规则-线程的start()方法先行于此线程内的其他方法
      3. 线程终止规则-线程的所有操作先行于线程的jon()方法返回
      4. 线程中断规则-对线程的interrupt()先行于线程感知到中断事件
      5. 监视器规则-一个锁的unlock先行于后续的lock
      6. volatile规则-volatile的写操作先行于后续读操作
      7. 对象初始化规则-对象的初始化先行于finalize()方法
      8. 传递性规则-a先行于b,b先行于c,则a先行于c
4. 线程安全
   1. 当多个线程访问一个对象时
   2. 可以不用考虑这些线程在运行环境下的调度和交替执行
   3. 可以不用进行额外的同步操作
   4. 可以不依赖调用方的其他同步机制
   5. 都可以成功获取这个对象,并且结果是正确的
   6. 方法
      1. 阻塞同步/互斥同步/悲观锁
         1. synchronize是最基本的互斥同步机制
         2. synchronize关键字在编译后在同步块前后形成monitorether和monitorexist指令
         3. 通过锁的计数,来实现阻塞
         4. 阻塞和唤醒都需要操作系统来完成
         5. 用户态和内核态的切换,耗时
         6. java.util.concurrent下的重入锁-ReentrantLock也可以实现同步
            1. 等待可中断
            2. 可实现公平锁
            3. 锁可以绑定多个条件
      2. 非阻塞同步/乐观锁
         1. 随着硬件指令集的发展,出现基于冲突检测的乐观并发机制
         2. 出现线程冲突时,使用补偿措施(重试)
         3. cas-比较并交换(compare-and-swap)-但存在ABA问题
            1. J.U.C 包提供了一个带有标记的原子引用类解决
            2. 通过控制变量值的版本来保证 CAS 的正确性
            3. 改用传统的互斥同步可能会比原子类更高效
      3. 无同步方案
         1. 可重入代码-只要输入相同的参数,一定返回相同的结果
         2. 线程本地存储-共享数据的代码在同一个线程中执行-ThreadLocalMap
         3. 栈封闭-多个线程访问同一个线程的局部方法变量-因为局部变量存储在虚拟机栈中，属于线程私有的
   7. 锁升级
      1. 偏向锁-期望一段时间内虽然上锁,但只有一个线程使用,线程之间不并发
         1. 撤销偏向,需要持有线程执行到安全点暂停
         2. 线程结束则标记为可重偏向
         3. 还在同步内则进行锁升级
      2. 轻量级锁-认为竞争,但竞争不多,且通过自旋的等待消耗比用户态和内核态切换消耗少
         1. 适应性自旋-JVM会根据锁的历史竞争情况动态调整自旋次数,避免无限制自旋浪费CPU性能
      3. 重量级锁-依赖系统互斥量,在用户态和内核态直接切换
      4. 偏向锁和轻量级锁,更偏向在用户态完成锁语义,避免锁的状态转换的消耗
         1. 用于暂停和唤醒线程的用户态到内核态的转换

## 面试
1. new会发生什么
   1. 类加载
      1. 先去运行时常量池查询这个类的符号引用
      2. 类是否被加载,解析,初始化-如果没有,则进行类加载
   2. 内存分配
      1. 是否栈上分配
      2. 分配内存
         1. 是否触发GC
      3. 判断是否要求线程安全
      4. 判断是否直接分配老年代
   3. 对象初始化
      1. 准备-默认初始化-零值-(0,false,null)
      2. 设置对象头
         1. class对象指针-哪个类的实例
         2. 类的元数据
         3. hash
         4. gc年龄
   4. 构造函数执行-init
   5. 返回对象引用

2. synchronize和lock的区别
   1. 实现
      1. synchronize是一个关键字,在JVM层面完成
      2. Lock的一个类
   2. 释放锁
      1. 同步完成或异常
      2. 在finally代码中,要不然容易死锁
   3. 原理
      1. 互斥同步/悲观锁
      2. 乐观锁,基于volatile与cas完成
   4. 特性
      1. 可重入,不可中断,非公平
      2. 可重入,可中断,公平/非公平,支持锁的嵌套(多个条件)
   5. 锁状态
      1. 无法判断
      2. 可判断
   6. 适用场景
      1. 少量的锁
      2. 大量的同步

3. 死锁
   1. 原因
      1. 使用Lock类,但未在finally中unlock
      2. 多个线程循环依赖,互相竞争,无法释放
      3. 2个线程同时持有一个线程的对象,一个进行中断,一个进行恢复,但目前这2个方法已经被废弃
   2. 解决办法
      1. 避免循环嵌套锁
      2. 锁排序
      3. 使用java.util.concurrent包下的锁方法
      4. 锁要有超时时间,避免无限期等待
      5. 检测
         1. 使用jConsole检测死锁
         2. 使用jstack分析线程dump
         3. visualvm分析堆内存
      6. 银行家算法
         1. 模拟资源分配过程,确保每次分配资源都是在安全状态下

4. 什么时候进行full Gc
   1. System.gc()
   2. 大字符串直接进入老年代时空间不足
   3. minor GC时会检查老年代中的连续空间是否大于新生代对象之和
      1. 足够-minor GC
      2. 不够-是否打开冒险开关
         1. 冒险开-full GC
         2. 不冒险-检查之前晋级老年代的空间大小的平均值在老年代中是否连续
            1. 大于-full GC
            2. 小于-进行分配担保
               1. 如果不足本次,则进行full GC
   4. 方法区空间不足-JDK8之前
   5. CMS GC失败时

5. 双亲委派模型的应用
   1. tomcat-不同的类加载器去加载不同的目录下划分了不同功能的模块,互不影响
   2. cglib-通过获当前的类加载器,动态生成字节码文件
   3. osgi-每个模块(Boudle)都有自己的类加载器,替换模块时,类加载器也会替换,达到热加载的目的
   4. JDBC-通过类加载器触发加载不同的数据库驱动-前序已经进行了驱动注册
      1. JDBC 4.0支持了自动加载指定目录下驱动

6. 内存异常
   1. 堆内存
      1. 设置JVM参数
         1. 通过Xmx与Xms设置堆最大与最小内存
         2. jvm参数设定再发生内存溢出时转存到特定目录的dump文件
      2. 命令行工具
         1. jps查看当前运行的java 进程id
         2. jstat 查看内存与GC情况 可设定刷新间隔
         3. jmap 生成dump文件
      3. 图形化分析
         1. visualVM
      4. 原因
         1. 分配大字符串或大数组,老年代中没有足够的连续空间,full GC后还是没有足够
         2. 新生代晋级到老年代,full GC后还是没有足够
   2. 虚拟机栈与本地方法栈
      1. stackOverFlowError
      2. OutOfMemoryError
   3. 方法区和运行时常量池溢出
      1. OutOfMemoryError
   4. 本机内存溢出
      1. OutOfMemoryError 但dump文件比较小
