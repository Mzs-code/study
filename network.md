# 网络

## 网络分层
1. [![](https://s21.ax1x.com/2025/01/17/pEFO6OS.png)](https://imgse.com/i/pEFO6OS)
2. ![](https://pic1.imgdb.cn/item/678a17c2d0e0a243d4f5344e.png)
3. 是一个一层层叠加协议内容的流程
4. 应用层-HTTP DNS SMTP FTP
   1. 规定了应用程序之间如何相互传递报文
   2. HTTP
      1. HTTP 客户端和 HTTP 服务端的首要工作就是根据 HTTP 协议的标准组装和解析 HTTP 数据包
      2. ![](https://pic1.imgdb.cn/item/678a0f03d0e0a243d4f52e35.png)
      3. 起始行-start line-分为「请求行」和「响应行」
      4. 首部(header),首部采用形如key:value的方式,比如常见的User-Agent、ETag、Content-Length
      5. 可选的实体(entity),实体是 HTTP 真正要传输的内容
   3. 其他协议
      1. 域名解析协议 DNS
      2. 收发邮件 SMTP 和 POP3 协议
      3. 时钟同步协议 NTP
      4. 网络文件共享协议 NFS
   4. 状态码
      1. 1XX - 信息型,服务器收到请求,需要请求者继续操作
      2. 2XX - 成功型,请求成功收到,理解并处理
      3. 3XX - 重定向,需要进一步的操作以完成请求
      4. 4XX - 客户端错误,请求包含语法错误或无法完成请求
      5. 5XX - 服务器错误,服务器在处理请求的过程中发生了错误
   5. 1.0与1.1和2.0的区别
      1. 区别
         1. 传输格式:文本与二进制
         2. 1.x只能按照请求顺序返回,2.0可以乱序
         3. 1.x一个TCP只能执行一个请求,2.0可以执行多个
         4. 队头阻塞-1.x需要创建多个TCP,2.0一个域名只需一个TCP
         5. 2.0性能更好,gRPC使用2.0作为通信协议
      2. 1.0
         1. 无状态无连接的应用层协议
         2. 无连接-每次连接都要新建一个TCP连接,服务端返回后马上断开
         3. 无状态-服务器不跟踪每个客户端,也不记录过去的请求-可以借助cookie/session机制
         4. 缺陷
            1. 无法复用连接,网络的利用率低
            2. 队头堵塞(head of line blocking)
            3. 1.0要求下一个请求必须在上一个请求处理完成后才能进行
      3. 1.1
         1. 新增长连接(Connection字段),通过设置Keep-alive来保持连接不断开
         2. 支持请求管道化(pipelining)
            1. 并不是真正意义上的并行传输
            2. 存在局限性
            3. 实际应用通常采用多开几个TCP连接
         3. 其他-还加入了缓存处理,新的字段如cache-control,支持断点传输,以及增加了Host字段
      4. 2.0
         1. 帧:HTTP/2 数据通信的最小单位消息
         2. 流:存在于连接中的一个虚拟通道。流可以承载双向消息,每个流都有一个唯一的整数ID
         3. 消息:与逻辑消息对应的完整的一系列数据帧
         4. 采用二进制格式传输数据,而非 HTTP/1.x 的文本格式,解析更高效-将请求和响应数据分割为更小的帧,并且它们采用二进制编码
         5. 多路复用
            1. 实现了真正的并行传输,它能够在一个TCP上进行任意数量HTTP请求
            2. 同个域名只需要占用一个TCP连接
               1. 消除了因多个TCP连接而带来的延时和内存消耗
               2. 可以并行交错地请求和响应,之间互不干扰
            3. 可以承载任意数量的双向数据流
            4. 支持了优先级策略,可以更加灵活
            5. 数据流以消息的形式发送,而消息又由一个或多个帧组成,多个帧之间可以乱序发送
               1. 根据帧首部的流标识可以重新组装
               2. 传输性能提高
         6. 服务器推送-服务端可以在发送页面HTML时主动推送其它资源
         7. 头部压缩-使用encoder来减少需要传输的header大小,加快传输
   6. cookie与session
      1. cookie-存储在客户端-不可跨域-相同的一级域名共享
      2. session-是基于 cookie 实现的,session 存储在服务器端-sessionId 会被存储到客户端的cookie 中
   7. HTTPS
      1. ![](https://pic1.imgdb.cn/item/678a1478d0e0a243d4f5328e.png)
      2. 在 HTTP 基础上加入 SSL/TLS 加密层的安全通信协议-SSL是TLS的前身,目前普遍使用TLS
      3. 默认端口443,hhtp默认80
      4. HTTPS除了 TCP 的三个包,还要加上 ssl 握手需要的 9 个包,所以一共是 12 个包
      5. 流程
         1. 客户端发起请求
         2. 服务端返回证书-公钥,证书,域名
         3. 客户端验证证书-有效期,签发机构CA
         4. 客户端随机生成对称加密秘钥-再用服务端公钥加密
         5. 服务端用自己的私钥解密-获取对接加密秘钥
         6. 后续通信将使用该密钥进行对称加密
      6. 先非对称加密,再对称加密-先使用非对称加密传递客户端随机生成的私钥,再通过对称加密对请求和响应进行加密通信
      7. 安全
         1. 加密通信内容
         2. 身份验证-CA证书验证服务端-避免中间人攻击
         3. 数据完整-使用hash算法确认数据未被篡改
   8. 缓存
      1. 本地缓存(强缓存)-向浏览器缓存查找该请求结果,并根据该结果的缓存规则来决定是否使用该缓存结果的过程
         1. Expires(HTTP/1.0)
         2. Cache-Control(HTTP/1.1)
      2. 协商缓存(再验证)-强缓存失效后,浏览器携带缓存标识向服务器发起请求,由服务器根据缓存标识决定是否使用缓存的过程
         1. Last-Modified 和 If-Modified-Since(HTTP/1.0)
         2. ETag 和 If-None-Match(HTTP/1.1)
5. 传输层-TCP-UDP
   1. 对传输行为进行控制
   2. 传输层用端口号来标识不同的应用程序,主机收到数据包以后根据目标端口号将数据包传递给对应的应用程序进行处理
   3. TCP-传输控制协议(Transmission Control Protocol)-为下面两层协议提供数据包的重传、流量控制、拥塞控制等
6. 网络层-IP
   1. ![](https://pic1.imgdb.cn/item/678a0e4ed0e0a243d4f52dec.png)
   2. IP 协议是一个无连接的协议,也不具备重发机制
   3. 提供了主机到主机的通信,将传输层产生的的数据包封装成分组数据包发送到目标主机,并提供路由选择的能力
7. 链路层-Ethernet
   1. 提供了主机连接到物理网络需要的硬件和相关的协议
8. 分层的好处
   1. 各层独立-限制了各层的职责范围,各层直接使用标准化接口
   2. 灵活-比如路由器不需要应用层和传输层,则无需加载
   3. 便于测试和维护-可以单独测试,也支持单层替换升级
   4. 促进标准化

## TCP
1. TCP/IP并不代表 TCP IP 2两种协议,而是TCP/IP协议族,在 IP 协议通信过程中用到的协议的统称
2. 特点
   1. 面向连接-需要通过「握手」建立一个逻辑连接或断开连接
   2. 可靠的
      1. 校验和(checksum)-校验和错误的报文,直接丢弃,等待发送端重传
      2. 包的序列号-保证了接收数据的乱序和重复问题
         1. 根据序号进行重新的排列
         2. 重复数据丢弃
      3. 超时重试
      4. 流量控制,拥堵控制
   3. 字节流-是一种字节流(byte-stream)协议,流的含义是没有固定的报文边界
   4. 全双工-通信的双方在任意时刻既可以是接收数据也可以是发送数据,每个方向的数据流都独立管理序列号、滑动窗口大小、MSS 等信息
3. 三次握手
   1. 通过三次数据交换建立TCP连接的过程
   2. 除了交换彼此的初始序列号,三次握手的另一个重要作用是交换一些辅助信息,比如最大段大小(MSS)、窗口大小(Win)、窗口缩放因子(WS)、是否支持选择确认(SACK_PERM)等
   3. ![](https://pic1.imgdb.cn/item/678a1be4d0e0a243d4f535d0.png)
   4. ![](https://pic1.imgdb.cn/item/678a1be6d0e0a243d4f535d1.png)
   5. ![](https://pic1.imgdb.cn/item/678a2e13d0e0a243d4f53d1a.png)
   6. 流程
      1. 第一次握手
         1. 客户端标志位SYN=1,生成随机序列化seq=x,向服务端发送,客户端进入syn_sent状态
         2. 同时会开启一个定时任务,服务端如果超时未返回,客户端会重发
      2. 第二次握手
         1. 服务端收到客户端的请求,因为请求中标志位SYN=1说明是建立连接
         2. 则构建标志位SYN=1,ACK=1,ack(确认号)=x+1,同时生成随机序列化seq=y,向客户端发送,自身进入syn_rcvd状态
      3. 第三次握手
         1. 客户端收到请求后,检查ack是否是等于x+1
         2. 如果正确,则将标志位ACK=1,ack(确认号)=y+1,发送给服务端
         3. 服务端收到后,检查标志位ACK=1和ack是否=y+1
         4. 如果正确,则客户端和服务端都进入ESTABLISHED状态,连接建立成功
4. 4次挥手
   1. ![](https://pic1.imgdb.cn/item/678a310cd0e0a243d4f53daa.png)
   2. ![](https://pic1.imgdb.cn/item/678a310cd0e0a243d4f53dab.png)
   3. 即终止TCP连接,就是指断开一个TCP连接时,需要客户端和服务端总共发送四个包来确定连接的断开
   4. 由于TCP是全双工的,所以关闭要2个方向都要单独关闭
      1. 当一方完成数据发送任务后,发送一个FIN来终止这一方向的连接
      2. 但另外一个方向还存在数据流动(还能发送数据),需要也发一个FIN
   5. 流程
      1. 第一次握手
         1. 客户端标志位FIN=1,生成随机序列化seq=x,向服务端发送,客户端进入fin_wait_1状态
      2. 第二次握手
         1. 服务端收到后,通过标志位FIN=1确定是要关闭连接,则向客户端发送标志位ACK=1,ack(确认号)=x+1,进入close_wait
         2. 客户端收到后,进入fin_wait_2
      3. 第三次握手
         1. 等服务端所有数据传输完成后,构建数据包,标志位FIN=1,生成随机序列化seq=y,进入last_ack
      4. 第四次握手
         1. 客户端收到后进入time_wait状态,并返回一个数据包,其中标志位ACK=1,ack(确认号)=y+1,服务端进入close状态
         2. time_wait是一个持续状态,4分后才进入close状态
         3. 客户端在2个MSL(报文最大生存时间)后进入close状态
   6. 延迟确认
      1. 第二步的ACK和第三步的FIN一起发送-就变成了3次挥手
      2. 但客户端可能会重发FIN
   7. 同时关闭-是可以的,如果在发送 FIN 之前收到了对端的 FIN,只会有一端进入TIME_WAIT
5. 为什么建立连接是三次握手,而关闭连接却是四次挥手
   1. 建立连接时,服务端将ack和syn放在一个报文内
   2. 而断开连接时,客户端提出关闭只代表一个方向的数据传输中断,服务端可能还有数据要传输完成,所以ack和fin分开进行
   3. 四次挥手也并不总是四次挥手-如果服务端没有其他数据要传输了,会将2,3步一起执行,客户端直接从fin_wait_1进入time_wait
6. 如何保证传输可靠性
   1. 应用数据被分割成TCP认为最适合发送的数据块
   2. 发生数据时,会启动一个定时器.超时重发
   3. 当TCP收到发自TCP连接另一端数据,它将发送一个确认
   4. 校验出包有错,丢弃报文段,不给出响应
   5. 对失序数据进行重新排序,然后才交给应用层
   6. 对于重复数据,能够丢弃重复数据
   7. TCP可以进行流量控制,防止较快主机致使较慢主机的缓冲区溢出
   8. 采用字节流服务
7. 结构
   1. ![](https://pic1.imgdb.cn/item/678a5bcdd0e0a243d4f5467e.png)
   2. 源端口号、目标端口号
      1. TCP 的报文里是没有源 ip 和目标 ip 的
      2. 源 IP、源端口、目标 IP、目标端口构成了 TCP 连接的「四元组」。一个四元组可以唯一标识一个连接
   3. 序列号(Sequence number)
      1. 报文段第一个字节的序列号
      2. 在 SYN 报文中,序列号用于交换彼此的初始序列号
         1. 初始序列号(Initial Sequence Number, ISN)
         2. 初始序列号的计算函数是MD5,元素是源地址、目标地址、源端口、目标端口和随机因子+时间
         3. 随机生成的优点
            1. 安全性高,难以伪造
            2. 保证两次连接的ISN不会相同,不发生串包
      3. 在其它报文中,序列号用于保证包的顺序
   4. 确认号(Acknowledgment number, ACK)
      1. 告知对方下一个期望接收的序列号,小于此确认号的所有字节都已经收到
   5. 标志位(TCP Flags)
      1. SYN(Synchronize)：用于发起连接数据包同步双方的初始序列号
      2. ACK(Acknowledge)：确认数据包
      3. RST(Reset)：这个标记用来强制断开连接,通常是之前建立的连接已经不在了、包不合法、或者实在无能为力处理
      4. FIN(Finish)：通知对方我发完了所有数据,准备断开连接,后面我不会再发数据包给你了
      5. PSH(Push)：告知对方这些数据包收到以后应该马上交给上层应用,不能缓存起来
   6. 窗口大小(window size)
      1. 旧设计最大窗口只有64kb
      2. 引入了"TCP 窗口缩放"来放大窗口大小-窗口缩放值在三次握手的时候指定
   7. 可选项
      1. 格式如kind=2,length=4,value=1460
      2. MSS：最大段大小选项,是 TCP 允许的从对方接收的最大报文段
      3. SACK：选择确认选项
      4. Window Scale：窗口缩放选项
      5. TCP 头部时间戳选项(TCP Timestamps Option,TSopt)
         1. ![](https://pic1.imgdb.cn/item/678a5ca6d0e0a243d4f546a1.png)
         2. 发送方时间戳(TS value)、回显时间戳(TS Echo Reply)
         3. ![](https://pic1.imgdb.cn/item/678a5cd4d0e0a243d4f546a3.png)
         4. 两端往返时延测量(RTTM)-针对ACK中的2个时间进行计算
         5. 解决序列号回绕(PAWS)-内核会维护一个为每个连接维护一个 ts_recent 值,记录最后一次通信的的 timestamps 值,延迟过大包会被丢弃
         6. 三次握手的第二步中,如果返回的SYN+ACK中的TSecr不等于第一次握手时发送的TSVal,则客户端会返回RST数据(断开连接)
8. 最大传输单元(Maximum Transmission Unit, MTU)
   1. 链路层
   2. 当一个 IP 数据包大于 MTU 时,IP 会把数据报文进行切割为多个小的片段(小于 MTU)
9.  TCP 最大段大小(Max Segment Size,MSS)
    1. ![](https://pic1.imgdb.cn/item/678a5e3cd0e0a243d4f5470a.png)
    2. 传输层
    3. MSS = MTU - IP header头大小 - TCP 头大小
    4. 在以太网中 TCP 的 MSS = 1500(MTU) - 20(IP 头大小) - 20(TCP 头大小)= 1460
    5. TCP 层为了 IP 层不用分片主动将包切割成 MSS 大小
    6. TSO(TCP Segment Offload)特性
       1. TSO 特性是指由网卡代替 CPU 实现 packet 的分段和合并,节省系统资源,因此 TCP 可以抓到超过 MTU 的包,但是不是真正传输的单个包会超过链路的 MTU
10. 特殊情形
    1. 同时发起连接
       1. ![](https://pic1.imgdb.cn/item/678a5ebed0e0a243d4f54731.png)
       2. 系统支持,但比较少见-类似于同时出现了2个服务端的状态变化
    2. 自连接
       1. 自连接-发起的连接最后连接到了自己
       2. 当一方主动发起连接时,操作系统会自动分配一个临时端口号给连接主动发起方。如果刚好分配的临时端口是 发起连接 端口时,就会出现
       3. 缺陷
          1. 占用端口,导致连接无法完成
          2. 无法通信
       4. 解决办法
          1. 让服务监听的端口与客户端随机分配的端口不可能相同即可
          2. 出现自连接的时候,主动关掉连接
    3. 同时关闭
       1. ![](https://pic1.imgdb.cn/item/678a5ed2d0e0a243d4f54735.png)
11. 扩展
    1. 半连接队列
       1. ![](https://pic1.imgdb.cn/item/678f39a6d0e0a243d4f61462.png)
       2. 服务端收到客户端的 SYN 包,回复 SYN+ACK 但是还没有收到客户端 ACK 情况下,会将连接信息放入半连接队列。半连接队列又被称为 SYN 队列
       3. 队列的大小是可以设置的,当队列已满时,建立连接的过程会阻塞
    2. 全连接队列
       1. 服务端完成了三次握手,但是还未被 accept 取走的连接队列。全连接队列又被称为 Accept 队列
    3. SYN flood 攻击
       1. ![](https://pic1.imgdb.cn/item/678f3a09d0e0a243d4f6148f.png)
       2. 客户端大量伪造 IP 发送 SYN 包,服务端回复的 ACK+SYN 去到了一个「未知」的 IP 地址,势必会造成服务端大量的连接处于 SYN_RCVD 状态,而服务器的半连接队列大小也是有限的,如果半连接队列满,也会出现无法处理正常请求的情况
       3. SYN Cookie 机制
          1. ![](https://pic1.imgdb.cn/item/678f3a09d0e0a243d4f61490.png)
          2. 基于「无状态」的机制,服务端收到 SYN 包以后不马上分配内存资源,而是根据这个 SYN 包计算出一个 Cookie 值,后续第三次握手后再进行cookie,有效才建立连接
    4. TCP 快速打开(TCP Fast Open,TFO)
       1. 默认关闭
       2. ![](https://pic1.imgdb.cn/item/678f3aead0e0a243d4f614d0.png)
       3. 在开启 TCP Fast Open以后,从第二次请求开始,就可以在一个 RTT 时间拿到响应的数据
    5. 服务单发起断开连接
       1. 服务端主动断开连接以后,需要等 2 个 MSL 以后才最终释放这个连接,重启再启用相同端口会失败
       2. 大多数操作系统的实现要求更加严格,只要还有连接在使用这个本地端口,则本地端口不能被重用(bind 调用失败)
       3. 启用 SO_REUSEADDR 套接字选项可以解除这个限制
    6. 多个进程监听同一个端口
       1. SO_REUSEPORT-port sharding
       2. 内核为处于 LISTEN 状态的 socket 分配了大小为 32 哈希桶。监听的端口号经过哈希算法运算打散到这些哈希桶中,相同哈希的端口采用拉链法解决冲突
       3. 当收到客户端的 SYN 握手报文以后,会根据目标端口号的哈希值计算出哈希冲突链表,然后遍历这条哈希链表得到最匹配的得分最高的 Socket
       4. SO_REUSEPORT启用后会通过随机算法选择进程
       5. Linux 内核在 4.5 和 4.6 版本中分别为 UDP 和 TCP 引入了 SO_REUSEPORT group 的概念,在查找匹配的 socket 时,就不用遍历整条冲突链,对于设置了 SO_REUSEPORT 选项的 socket 经过二次哈希找到对应的 SO_REUSEPORT group,从中随机选择一个进行处理
       6. 实现了内核级的负载均衡与支持滚动升级(Rolling updates)上下线节点
    7. SO_LINGER 套接字
       1. 调整close()方法策略
    8. TIME_WAIT
       1. 只有主动断开的那一方才会进入 TIME_WAIT 状态,且会在那个状态持续 2 个 MSL(Max Segment Lifetime)
       2. MSL：Max Segment Lifetime-报文最大生存时间
       3. 2MS = 去向 ACK 消息最大存活时间(MSL) + 来向 FIN 消息的最大存活时间(MSL)
       4. 可靠的实现 TCP 全双工的连接终止(处理最后 ACK 丢失的情况)2.避免当前关闭连接与后续连接混淆(让旧连接的包在网络中消逝)
       5. 可以结合时间戳进行不同设置调整策略
    9. RST
       1. 端口未监听
       2. 连接信息丢失,另一方并不知道继续发送数据
       3. SO_LINGER 设置丢弃缓冲区数据,close()立刻 RST
    10. 重传
        1. ACK 是表示这之前的包都已经全部收到
        2. 快速重传机制-当发送端收到 3 个或以上重复 ACK,就意识到之前发的包可能丢了,于是马上进行重传,不用傻傻的等到超时再重传
        3. ![](https://pic1.imgdb.cn/item/678f55c5d0e0a243d4f62071.png)
        4. 超时重传的时间(Retransmission TimeOut,RTO)-经典方法：适用 RTT 波动较小的情况-标准方法：对 RTT 波动较大的情况下有更好的适应效果
    11. 滑动窗口
        1. 对发送端的数据流量控制的方式
        2. TCP 在收到数据包回复的 ACK 包里会带上自己接收窗口的大小,接收端需要根据这个值调整自己的发送策略
        3. ![](https://pic1.imgdb.cn/item/678f5647d0e0a243d4f620a5.png)
        4. TCP Window Full
           1. ![](https://pic1.imgdb.cn/item/678f5648d0e0a243d4f620a6.png)
           2. 包的发送方已经把对方所声明的接收窗口耗尽了
           3. 不是一个 TCP 的标记,而是 wireshark 智能帮忙分析出来的
           4. 是站在发送端角度说的,表示在途字节数等于对方接收窗口的情况
        5. TCP Zero Window
           1. 一个长度为 0 的 ACK 包,Seq 为当前连接 Seq 最大值减一
           2. 会重试,时间间隔指数级增长
           3. 零窗口探测的机制(Zero window probe)
           4. 是站在接收端角度来说的,是接收端接收窗口满
    12. 拥堵控制
        1. 拥塞窗口指的是在收到对端 ACK 之前自己还能传输的最大 MSS 段数
        2. 接收窗口(rwnd)是接收端的限制,是接收端还能接收的数据量大小
        3. 拥塞窗口(cwnd)是发送端的限制,是发送端在还未收到对端 ACK 之前还能发送的数据量大小
        4. 真正的发送窗口大小 = 「接收端接收窗口大小」 与 「发送端自己拥塞窗口大小」 两者的最小值
        5. 拥塞窗口初始值等于操作系统的一个变量 initcwnd,最新的 linux 系统 initcwnd 默认值等于 10
        6. ![](https://pic1.imgdb.cn/item/678f5759d0e0a243d4f620d6.png)
        7. 慢启动
           1. 拥塞窗口一开始是一个很小的值,然后每 RTT 时间翻倍
           2. 慢启动阈值(Slow Start Threshold,ssthresh)
        8. 拥塞避免
           1. 当拥塞窗口达到拥塞阈值(ssthresh)时,拥塞窗口从指数增长变为线性增长
           2. 慢启动的做法是 RTT 时间内每收到一个 ACK,拥塞窗口 cwnd 就加 1,也就是每经过 1 个 RTT,cwnd 翻倍拥塞避免的做法保守的多,每经过一个RTT 才将拥塞窗口加 1,不管期间收到多少个 ACK
           3. 快速重传-发送端接收到 3 个重复 ACK 时立即进行重传
           4. 快速恢复
              1. 当收到三次重复 ACK 时,进入快速恢复阶段,此时拥塞阈值降为之前的一半,然后进入线性增长阶段
              2. 拥塞阈值 ssthresh 降低为 cwnd 的一半：ssthresh = cwnd / 2拥塞窗口 cwnd 设置为 ssthresh拥塞窗口线性增加
    13. Nagle 算法
        1. ![](https://pic1.imgdb.cn/item/678f58ded0e0a243d4f6213d.png)
        2. 时代产物-在通信时延较低的场景下意义不大-减少发送端频繁的发送小包给对方
        3. 当第一次发送数据时不用等待,就算是 1byte 的小包也立即发送
        4. 后面发送数据时需要累积数据包直到满足下面的条件之一才会继续发送数据
           1. 数据包达到最大段大小MSS
           2. 接收端收到之前数据包的确认 ACK
    14. 延迟确认
        1. 延迟确认-(delayed ack)
        2. 不是每个数据包都对应一个 ACK 包,因为可以合并确认
        3. 也不是接收端收到数据以后必须立刻马上回复确认包
    15. keepalive
        1. TCP 的 half open(半打开)
        2. 定时发送探测包来探测连接的对端是否存活
        3. 由于默认配置时间太长(7200秒),大部分应用没有开启配置-而是选择在应用层做心跳机制
    16. Challenge ACK
        1. Linux 内核对于收到的乱序 SYN 报文,会回复一个携带了正确序列号和确认号的 ACK 报文。这个 ACK 被称之为 Challenge ACK
    17. 定时器
        1. 连接建立定时器
           1. ![](https://pic1.imgdb.cn/item/678f5a50d0e0a243d4f62186.png)
        2. 重传定时器
           1. ![](https://pic1.imgdb.cn/item/678f5a50d0e0a243d4f62187.png)
        3. 延迟 ACK 定时器
           1. ![](https://pic1.imgdb.cn/item/678f5a74d0e0a243d4f62195.png)
        4. PERSIST 定时器
           1. 专门为零窗口探测而准备的
           2. ![](https://pic1.imgdb.cn/item/678f5a74d0e0a243d4f62196.png)
        5. KEEPALIVE 定时器
           1. ![](https://pic1.imgdb.cn/item/678f5a98d0e0a243d4f6219b.png)
        6. FIN_WAIT_2 定时器
           1. ![](https://pic1.imgdb.cn/item/678f5a98d0e0a243d4f6219c.png)
        7. TIME_WAIT 定时器
           1. ![](https://pic1.imgdb.cn/item/678f5a99d0e0a243d4f6219d.png)

## 端口
1. 端口号是传输层的标志,最多为65535个-2^16 - 1-16位二进制数
2. 分层结构中每一层都有一个唯一标识,比如链路层的 MAC 地址,IP 层的 IP 地址,传输层是用端口号
3. 熟知端口号(Well Known Ports)
   1. 范围:0-1023
   2. 由IANA分配和管理
   3. 常见-HTTP:80-HTTPS:443-SSH:22
4. 已登记端口号(registered port)
   1. 范围:1024-49151
   2. 不受IANA控制,但由IANA登记并提供使用信息
   3. 常见-mysql:3306-redis:6379-MongoDB:27017
5. 临时端口号(ephemeral port)
   1. 范围:49152-65535
   2. IANA不管理
   3. 由系统随机分配,范围是 32768~60999
6. 通过 netstat 命令,可以查看进程监听端口的情况

## UDP
1. UDP为什么不可靠
   1. 不保证消息交付-不确认-不重传-无超时
   2. 不保证交付顺序-不设置包序号-不重排-不会发生队首阻塞
   3. 不跟踪连接状态-不必建立连接或重启状态机
   4. 不需要拥塞控制-不内置客户端或网络反馈机制
2. 无连接
3. 不重试
4. 无流量控制
5. 在涉及到NAT的网络中,实时性要求比较高的场景,UDP更合适
6. 直播场景,只关心未来数据

## IP
1. DNS域名解析过程
   1. 当用户在浏览器输入域名并按下回车后,浏览器会检查缓存中有没有该域名对应的街写过的的IP地址,若缓存中有,则解析过程结束
      1. (浏览器缓存域名是有限制的,不仅大小有限制,域名被缓存的时间通过TTL属性来设置.通常情况下为几分钟到几小时)
   2. 若浏览器缓存中没有,浏览器会在操作系统中(hosts文件)查找是否有这个域名对应的DNS解析结果.
   3. 如果1,2步无法解析,操作系统会将这个域名发送给LDNS.也就是本区域的域名服务器.
      1. (电信等)这个专门的域名解析服务器性能都比较好,大约80%的域名解析都到这里就已经完成了,所以LDNS主要承担了域名的解析工作.
   4. 若LDNS没有解析成功,就直接到Root Server域名服务器请求解析.
   5. 根域名服务器返回本地域名服务器一个查询域的主域名服务器(gTLD Server)地址.
      1. gTLD是国际顶级域名服务器,如.com,.cn,.org等,全球只有13台左右.
   6. 本地域名服务器(Local DNS Server)再向上一步返回的gTLD服务器发送请求.
   7. 接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址,这个Name Server通常就是你注册的域名服务器.
   8. Name Server域名服务器会查询存储的域名和IP的映射关系表,在正常情况下都根据域名得到目标IP记录,连同一个TTL值返回给DNS Server域名服务器.
   9. 返回该域名对应的IP和TTL值,Local DNS Server会缓存这个域名和IP的对应关系,缓存的时间由TTL值控制.
   10. 把缓存的结果返回给用户,用户根据TTL值缓存在本地系统中,域名解析过程结束.
2. 浏览器输入url后发生了什么
   1. DNS域名解析
   2. 建立TCP连接
   3. 发送HTTP请求
   4. 服务器处理请求
   5. 返回响应结果
   6. 关闭TCP连接
   7. 浏览器解析HTML
   8. 浏览器布局渲染
3. ping的过程
   1. ping程序依赖于ICMP协议,并结合ARP协议实现,ipv6是基于NDP(邻居发现协议)
      1. ICMP
         1. Internet Controller Message Protocol-因特网控制报文协议
         2. 是一个差错报告机制,用于在IP主机、路由器之间传递控制消息
         3. ip协议是一个尽力而为的协议,只关心尽快传递数据,而不对目的主机是否收到消息进行验证,无法进行流量控制与差错控制
         4. ICMP可以上报数据传输情况和异常情况
            1. 远程主机是否可达
            2. 延迟
            3. 报文丢失情况
         5. ICMP报文被封装在ip数据包内部,作为IP数据包的数据部分通过互联网传递
      2. ARP
         1. Address Resolution Protocol
         2. 根据IP地址查找出对应ip地址的MAC地址
         3. 每个主机都会一个ARP缓存(ip与mac地址映射)
   2. 流程
      1. ping程序先构建一个ICMP数据包-ICMP打包这个数据包和目标主机的地址给到ip协议层
      2. ip协议将目标主机的ip地址为目的地址,本机地址为源地址,加上一些其他控制信息,构成一个ip数据包
      3. 通过ARP协议获取目标主机的mac地址
      4. 拿到目标主机的mac地址后,在链路层构建以太传输数据帧,根据以太网的介质访问规则广播出去
      5. 目标主机收到请求后,会先检查mac地址是否一致,再一层层向上传输到
      6. 再重复流程,构建ICMP响应数据包,原路返回
4. ipv4 ipv6
   1. ipv4
      1. 32位,2的32次方
      2. 点分十进制
   2. ipv6
      1. 128位,2的128次方
      2. 冒号16进制,最多一个双冒号
      3. 优点
         1. 地址更多
         2. 更小的路由表
         3. 更好的组播与流功能,有利多媒体数据
         4. 安全性更好
         5. 自动配置-根据mac地址生成ipv6地址
         6. 更好的格式,更多的配置功能

## Netty

## rpc

## 面试题
1. 收到 IP 数据包解析以后,它怎么知道这个分组应该投递到上层的哪一个协议(UDP 或 TCP)
   1. IP 头里有一个“协议”字段,指出在上层使用的协议,比如值为 6 表示数据交给 TCP、值为 17 表示数据交给 UDP
2. TCP提供了一种字节流服务,而收发双方都不保持记录的边界,应用程序应该如何提供他们自己的记录标识呢?
   1. 应用程序使用自己约定的规则来表示消息的边界,比如有一些使用回车+换行("\r\n"),比如 Redis 的通信协议(RESP protocol)
3. TCP/IP 协议中,MSS 和 MTU 分别工作在哪一层?
   1. MSS-传输层
   2. MTU-链路层
4. 在 MTU=1500 字节的以太网中,TCP 报文的最大载荷为多少字节?
   1. 1460=1500-20-20
   2. 实际网络中,MSS 值通常通过 TCP 三次握手协商确定,默认值为 1460 字节(假设 IP 和 TCP 头均为 20 字节,且不考虑以太网帧头和 FCS(帧校验序列))
5. 小于()的 TCP/UDP 端口号已保留与现有服务一一对应,此数字以上的端口号可自由分配?
   1. 1024
6. TCP 的 keepalive 与 HTTP 的 keep-alive 有什么区别?
   1. TCP 的 keepalive是用于心跳检测
   2. HTTP 的 keep-alive是用于避免tcp断开连接
