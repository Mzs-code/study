# middleware

## spring
1. IOC
   1. 控制反转-Inverse of Control
   2. 在传统的程序中,需要主动创建对象实例.而在spring中则将这些交给了spring容器统一管理
   3. 依赖查找-Dependency Lookup,DL
      1. BeanFactory 根据指定的 beanName 去获取和创建对象的过程
      2. 拿到 BeanFactory / ApplicationContext 之后主动调用 getBean 方法
   4. 依赖注入-DI
      1. 创建被调用者实例的工作通常由spring容器来完成，然后注入调用者
      2. @Component和@Autowired注解
      3. 实现了组件之间的解耦
2. AOP
   1. Aspect Oriented Programming-面向切面编程
   2. 将应用业务做统一或特定的功能增强，能实现应用业务与增强逻辑的解耦
   3. 它是 OOP 的补充。OOP 关注的核心是对象，AOP 的核心是切面（Aspect）
   4. AOP可以在不修改原有代码的前提下,使用运行时动态代理的技术对已有代码进行增强
   5. AOP 可以实现组件化、可插拔式的功能扩展，通过简单配置即可将功能增强到指定的切入点
   6. 使用场景
      1. 业务日志切面：可以记录业务方法调用的痕迹事务控制
      2. 通过切面可以声明式控制事务权限校验
      3. 执行方法之前先校验当前登录用户是否有权调用数据缓存
      4. 执行方法之前先从缓存中取，取到则直接返回不走业务方法
   7. jdk动态代理-要求被代理的对象所属类至少实现一个接口，它是 jdk 内置的机制
   8. cglib动态代理-无此限制，使用字节码增强技术实现，需要依赖第三方 Cglib 包
   9. jdk 动态代理的代理对象创建速度快，执行速度慢；Cglib 动态代理的代理对象创建速度慢，执行速度快
3. 容器与事件-管理应用中使用的组件Bean、托管Bean的生命周期、事件与监听器的驱动机制
4. 其他-Web、事务控制、测试、与其他技术的整合
5. Bean的生命周期
   1. ![](https://pic1.imgdb.cn/item/67a6d32fd0e0a243d4fce8a2.png)
   2. 实例化
   3. 属性赋值
   4. 初始化
      1. Aware接口的依赖注入
      2. BeanPostProcessor前置处理
      3. InitializingBean
      4. init-method
      5. BeanPostProcessor后置处理
   5. 销毁
      1. 注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁
6. 三级缓存
   1. 主要是为了解决Spring容器内bean的循环依赖问题
   2. 依赖的是Bean的中间态状态-即Bean已经实例化,但还未初始化
   3. 理论依据是java中使用的是引用传递-即可以先获取对象的引用,对象的属性可以稍后设置
   4. 循环依赖的场景
      1. 构造器
         1. 启动会失败,因为构造器是要完成实例化的
      2. filed属性注入(setter方法注入)
      3. prototype field属性注入循环依赖
         1. 启动时候不会报错-因为非单例bean默认不会初始化,是使用时才初始化
         2. 在getBean或在单例bean中注入报错
   5. 创建Bean的流程
      1. ![](https://pic1.imgdb.cn/item/67a6d678d0e0a243d4fce993.png)
      2. createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象
      3. populateBean：填充属性，这一步主要是对bean的依赖属性进行注入(@Autowired)
      4. initializeBean：回到一些形如initMethod、InitializingBean等方法
   6. 三级缓存
      1. 一级-Map<String, Object> singletonObjects-存放已经实例化和初始化完成的bean,拿到即用
      2. 二级-Map<String, Object> earlySingletonObjects-提前曝光的单例对象的cache,存放的是中间态-已经完成实例化,但还未初始化-用于解决循环依赖
      3. 三级-Map<String, ObjectFactory<?>> singletonFactories-单例对象工厂的cache,存放的是bean的工厂对象-用于解决循环依赖
   7. ![](https://pic1.imgdb.cn/item/67a6d677d0e0a243d4fce992.png)
   8. A,B互相依赖流程
      1. context.getBean(A.class),A在容器中不存在,则进行创建流程
      2. A实例化,放入三级缓存中(A实例化完成,则可以引用了)-创建一个A的 Bean 工厂，并将此工厂加入到三级缓存中
      3. A初始化前,存在@Autowired依赖注入B,则去容器中找B,B不存在,则进行创建流程
      4. B实例化,放入三级缓存中
      5. B初始化前,存在@Autowired依赖注入A,则去容器中找A,A存在
         1. 在三级缓存中找到A,并将A放入二级缓存中,同时删除三级缓存中的A
      6. B初始化完成,返回A的初始化流程
         1. B放入一级缓存中,并删除二级与三级缓存中的B
      7. A初始化完成
         1. A放入一级缓存中,并删除二级与三级缓存中的A
   9. Spring AOP、事务等通过动态代理类实现-也只会创建一次Bean(代理类),循环依赖时也可以同样解决
   10. 为什么不只使用一级或二级缓存
       1. 如果只有一级,则无法解决循环依赖的问题
       2. 如果只有二级,可以解决部分循环依赖的问题,但无法解决代理对象的生成
          1. 通常没有循环依赖的情况下,代理类的创建是在Bean初始化完成后再进行,相当于延后进行
          2. 代理对象需要在原始bean初始化完成后生成,如果只有二级同时有循环依赖问题,则无法区分原始对象和代理对象
          3. 如果有循环依赖的情况下,就需要提前完成创建代理类的动作
             1. 在第三层缓存中ObjectFactory 中去提前创建代理对象
             2. 同时也会记录已被代理的对象
       3. 三级缓存存储 Bean 的工厂对象（支持代理对象的生成）
7. 事务
   1. 方式
      1. 编程式事务
         1. 事务模板类.execute
         2. 事务Manager
      2. 声明式事务
         1. 基于AOP实现
         2. @Transactional
            1. 如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话
            2. Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法
            3. 这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务
   2. Spring 并不直接管理事务，而是提供了多种事务管理器
   3. 核心在于何时将begin transaction、commit 、rollback这些sql语句发给mysql
   4. 事务管理接口
      1. PlatformTransactionManager:（平台）事务管理器，Spring 事务策略的核心
      2. TransactionDefinition:事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)
      3. TransactionStatus:事务运行状态
   5. 事务属性
      1. 事务传播行为-Propagation-默认REQUIRED-如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务
      2. 事务隔离级别-Isolation-ISOLATION_DEFAULT:使用后端数据库默认的隔离级别
      3. 事务超时属性-默认-1-不会超时
      4. 事务只读属性-指定事务是否为只读事务，默认值为 false
      5. 事务回滚规则-默认为RuntimeException以及对应的子集-常规需要配置为Exception
   6. 注意事项
      1. @Transactional 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用
      2. 避免同一个类中调用 @Transactional 注解的方法，这样会导致事务失效
      3. 正确的设置 @Transactional 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败
      4. 被 @Transactional 注解的方法所在的类必须被 Spring 管理，否则不生效
      5. 底层使用的数据库必须支持事务机制，否则不生效；
8. 分布式事务
   1. 理论
      1. CAP
         1. C-Consistency-一致性
         2. A-Availability-可用性
         3. P-Partition Tolerance-分区容错性
         4. CAP三者无法同时满足,只能满足其中的2点
         5. 一般是满足可用性和分区容错性,再结合弱一致性或最终一致性
      2. BASE
         1. Basically Available-基本可用-指分布式系统在出现故障的时候，允许损失部分可用性，保证核心可用
         2. Soft-state-软状态-允许系统存在中间状态，并且该中间状态不会影响系统整体可用性-即允许系统在不同节点间副本同步的时候存在延时
         3. Eventual Consistency-最终一致性-系统中的所有数据副本经过一定时间后，最终能够达到一致的状态
      3. 一致性协议
         1. Gosssip
            1. 也叫 Epidemic 协议（流行病协议）
            2. 种子节点随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息
            3. 可能需要一定的时间,但最终会达成一致性
            4. 特点
               1. Gossip 协议是周期性散播消息，每隔一段时间传播一次
               2. 被感染的节点，每次可以继续散播 N 个节点
               3. 每次散播消息时，都会选择尚未发送过的节点进行散播，不会向已发送的节点散播
               4. 同一个节点可能会收到重复的消息，因为可能同时多个节点正好向它散播
               5. 集群是去中心化的，节点之间都是平等的
               6. 消息的散播不用等接收节点的 ack，即消息可能会丢失，但是最终应该会被感染
            5. 使用场景
               1. redis集群节点运行状态广播
               2. 一般用于网络拓扑结构信息的分享和维护
         2. Raft
            1. 在数据安全与性能中做折中,只要保证绝大部分节点同步数据成功就算成功
            2. 角色
               1. leader-数据变更从leader节点入口
               2. follower-负责复制数据并且在选举时候投票的节点
               3. candidate-候选人,leader从中诞生
               4. follower->candidate->leader
            3. 选举
               1. ![](https://pic1.imgdb.cn/item/67a7237fd0e0a243d4fd0c10.png)
               2. 定时器
                  1. 每个节点都有一个自己定时器,时间是随机的
                  2. 定时结束,发现当前没有leader节点,则把自身晋升为candidate候选人节点
               3. 流程
                  1. 一开始所有节点都是follower,定时器时间到了则晋升自己为candidate,给自己投一票,并通知其他节点投票
                     1. 当拿到半数投票,则晋升为leader
                  2. 其他节点投票,candidate晋升为leader
                     1. 并记录当前版本号
                     2. 版本号不一致的投票丢弃
                  3. leader节点定时发送心跳给follower,follower重置定时器
                  4. leader宕机,follower没收到心跳,则开始新的一轮选举
                     1. 如果2个候选人票数一样,则延迟随机时间重新投票
                     2. 先到先得
               4. 工作机制
                  1. leader节点收到客户端数据,记录到日志中(未确认状态),在下一次心跳时同步给follower
                  2. follower记录(未确认状态),并反馈给leader
                  3. 超过半数follower确认,则日志状态修改为已确认,并反馈给客户端
                     1. 如果总节点少于3个,则不能确认,返回错误信息给客户端
                  4. leader再次通知,follower记录状态改为确认
                  5. 网络出现分区问题时,也可以根据重新选举来完成
   2. 分布式事务会遇到的问题
      1. 一个事务对2个数据库操作
      2. 一个事务包含对多个数据分片操作
         1. 存在分库分表或涉及多个db或表
         2. 对于上层业务是不透明的
      3. 一个事务包含对多个业务的调用
   3. XA模型
      1. XA模式是一个理想化的分布式事务模型,没有考虑高并发,网络故障等问题
      2. 传统的分布式事务通过 XA 模型实现，通过一个事务协调者，站在全局的角度将多个子事务合并成一个分布式事务
      3. ![](https://pic1.imgdb.cn/item/67a700a9d0e0a243d4fcf8b6.png)
      4. 二阶段提交
         1. Prepare阶段-事务管理器确保相关资源都已经是就绪阶段
         2. Commit阶段
      5. 优点
         1. 提供了强一致性保证,在业务执行的任何时间点都能确保事务一致性
         2. 使用简单,常规的关系型数据库都支持XA模型,通过引入事务协调器,业务代码侵入性小
      6. 缺点
         1. 性能问题-两段式提交中,资源是阻塞的,吞吐量低
         2. 单点故障-事务协调者故障
         3. 数据不一致-部分节点回滚成功,部分节点回滚不成功
      7. 从mysql维度
         1. 外部XA-普遍使用场景是数据库中间件
         2. 内部XA
   4. 柔性事务
      1. 追求最终一致性
         1. 放弃了传统分布式事务的强一致性要求,允许在事务执行过程中,有一部分时候存在中间状态,在业务上需要允许容忍
      2. 基于CAP与BASE理论
         1. CAP
            1. C-一致性
            2. A-可用性
            3. P-分区容忍
         2. BASE
            1. 基本可用
            2. 软状态
            3. 最终一致
      3. ![](https://pic1.imgdb.cn/item/67a70268d0e0a243d4fcfaa4.png)
      4. 柔性事务有多种实现方式，包括 TCC、Saga、事务消息、最大努力通知等
      5. 事务消息
         1. ![](https://pic1.imgdb.cn/item/67a70332d0e0a243d4fcfc02.png)
         2. 确保本地事务执行和确保消息100%投递
            1. 采用提前发送半事务消息,暂时记录事件
            2. 本地事务执行完成,再发送确认消息
            3. 如果确认消息发送失败,之前发送的半事务消息会反向本地事务查询进行判断
            4. 同时可以支持多个节点处理
         3. 确保远程事务执行完成
            1. 远程事务执行完成后需要进行消息确认
            2. 否则会进行重复投递
         4. RocketMQ 提供了对于事务消息机制最完整实现，包括半事务消息、确认消息、事务回查机制、消息重试等重要功能
         5. 执行远程事务时会存在失败情况
            1. 技术异常-如网络波动或宕机等,重试机制已可以满足
            2. 业务异常-需要执行回退流程-也可以使用事务消息执行,相当于角色互换,但需要使用不同的消息topic或者新的事件类型
         6. 多个事务参与方
            1. 消息组不同进行消费
            2. ![](https://pic1.imgdb.cn/item/67a70333d0e0a243d4fcfc03.png)
         7. 简化事务消息的执行流程,进行预处理
            1. 存在业务校验,容易产生回滚的采用本地事务
            2. 出错较少,更多是记录的动作采用远程事务
         8. 其他注意事项
            1. 幂等控制
            2. 对账机制
               1. rocketMq存在最大重试机制
               2. 出现遗漏考虑的业务情况
               3. 消息组件或缓存组件出现异常
               4. 因此需要对账机制以及部分人工处理机制
   5. seata
      1. 阿里开源分布式事务框架-https://seata.apache.org/zh-cn/
      2. 支持 AT、TCC、SAGA 和 XA 事务模式
      3. 核心组件
         1. ![](https://pic1.imgdb.cn/item/67a70cccd0e0a243d4fd02d1.png)
         2. TM-Transaction Manager
            1. 在微服务架构中可对应为聚合服务，即将不同的微服务组合起来成一个完整的业务流程
            2. TM 的职责是开启一个全局事务或者提交或回滚一个全局事务
         3. TC-Transaction Coordinator
            1. 独立的服务，是一个独立的 JVM 进程，里面不包含任何业务代码
            2. 它的主要职责：维护着整个事务的全局状态，负责通知 RM 执行回滚或提交
            3. TC 是一个无状态服务，即纯粹的计算节点
         4. RM-Resource Manager
            1. 在微服务框架中对应具体的某个微服务为事务的分支
            2. RM 的职责是：执行每个事务分支的操作
      4. 流程
         1. TM开启全局事务
         2. RM 完成本地操作
         3. RM 向 TC 上报分支事务
            1. RM 完成本地事务操作（未提交），向 TC 上报分支事务（申请全局锁）
         4. TM 向 TC 提交全局事务
         5. RM 执行提交或回滚操作
      5. AT 模式-依赖关系型数据库的本地事务
         1. Seata 框架通过 Spring AOP、自动装配与注解等技术，生成 JDBC 数据源代理
         2. 并对业务方法进行拦截，自动实现分布式事务的处理，业务代码只需标注注解即可
         3. 对数据库也只需添加一张新的表，接入成本低-需要新增一张undo_log表,用于记录回滚日志记录
         4. 基于支持本地 ACID 事务的关系型数据库,对于代码侵入性小
         5. 利用数据库连接的代理与数据库本地事务特征，根据业务 sql 自动生成操作日志，并自动生成提交与回滚的操作逻辑
            1. 一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录
            2. 二阶段 commit 行为：马上成功结束，自动异步批量清理回滚日志
            3. 二阶段 rollback 行为：通过回滚日志，自动生成补偿操作，完成数据回滚
         6. 第一阶段-执行
            1. 解析 Sql，生成前镜像，执行 SQL 语句，生成后镜像
            2. 将 Sql 元信息，前镜像，后镜像，组织为一条回滚日志并插入到 UNDO_LOG 表中
            3. 向 TC 注册分支申请全局锁,全局锁的内容为：全局事务 ID，producet 表 ID，目的是为保证全局事务的隔离性
            4. 全局锁获取成功后,提交本地事务
            5. 向 TC 提交本地事务执行结果-TC判断第二阶段应该执行什么
         7. 第二阶段-回滚
            1. TM 发送回滚操作-TM 监测到异常后向 TC 执行全局回滚， TC 再向每个分支 RM 发送回滚请求
            2. 获取回滚日志-通过全局事务 XID 与分支事务 BranchID 找到回滚日志记录
            3. 校验前镜像数据与当前最新读到的数据
               1. 数据一样,说明中间没有其他事务操作,执行回滚
               2. 如果不一样,按照策略执行,用前镜像数据，还是用数据库中数据，还是不做处理送通知人工处理等等
               3. 执行回滚sql,提交本地事务
               4. 向TC上报回滚情况-如果本地事务执行失败或超时等，TC 会根据配置定时重新发送回滚操作，保证高可用
         8. 第二阶段-提交
            1. TC 发送提交操作-RM 收到提交操作后，先将请求放入到一个消息队列中并直接返回成功;
            2. 异步、批量删除回滚日志
      6. TCC 模式-不依赖于底层数据资源的事务支持
         1. TCC 模式，不依赖于底层数据资源的事务支持,自定义实现准备,提交,回滚阶段
         2. 一阶段 prepare 行为：调用自定义的 prepare 逻辑
         3. 二阶段 commit 行为：调用自定义的 commit 逻辑
         4. 二阶段 rollback 行为：调用自定义的 rollback 逻辑
      7. AT 模式与 TCC 模式比较
         1. TCC性能要远优于 AT 模型-TCC 模式不依赖本地事务也不需要额外的其他操作
         2. TCC 模式均可自定义,更灵活
         3. 适用场景不同-AT 模式适用于关系数据库，热点数据并发量不高的场景-TCC 模式适用于可预留资源，非关系型数据库，对并发要求高的场景
      8. SAGA-长事务解决方案
         1. 业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现
         2. 适用于业务流程长、业务流程多
         3. 优点
            1. 一阶段提交本地事务，无锁，高性能事件驱动架构，参与者可异步执行，高吞吐补偿服务易于实现
            2. 可以实现服务编排需求
         4. 缺点-无法保证隔离性
         5. 基于状态机引擎来实现
            1. 提前定义好json格式的状态语言定义文件
            2. 由状态机引擎驱动执行,出现异常时执行补偿机制
      9. XA模型-XA 模式与 AT 模式保持完全一致
      10. 高可用
          1. ![](https://pic1.imgdb.cn/item/67a710dbd0e0a243d4fd0536.png)
          2. TC是无状态集群
          3. 注册中心和配置中心即使宕机,节点也有缓存
          4. 不同节点之间网络不可用,一阶段的话不会执行,二阶段有重试机制
          5. 应用节点宕机,其他几点继续执行事务动作
      11. 隔离性
          1. 写隔离
             1. 通过持有全局锁来控制本地事务的提交，在一个分布式事务没有全部完成之前(包括提交与回滚)，会一直持有全局锁，而别的分布式事务只能等待，直到别的事务释放了全局锁
             2. 先获取本地事务锁,再获取全局锁
             3. 达到一个排队效果
          2. 读隔离
             1. Seata 框架在 AT 模式下，默认的隔离性级别为“未提交读”
             2. 已提交读,需要使用SELECT FOR UPDATE 语句
      12. 总结
          1. Seata AT 模式的整体运行机制是两阶段提交方案
          2. JDBC 代理自动创建回滚日志
             1. 对原始业务方法进行拦截，通过对 JDBC 连接操作进行代理
             2. 解析sql生成并保存回滚日志
             3. 自动提交,自动回滚
          3. 全局事务锁保证事务的隔离性
9. SpringBoot
   1. SpringBoot本质是基于Spring框架,进行简化配置,便于开发和脚手架搭建
   2. 打包产物是一个jar
   3. 自动装配
      1. SpringBoot约定了一套规范
         1. 启动时会扫描外部jar的特点路径下的文件
         2. 并将文件内容中的类加载到容器中,并执行对应方法
         3. 使用者主要引入特点的start包,以及对应配置和注解即可
      2. Spring其实已经实现了自动装配,SpringBoot基于SPI进行了优化
      3. SpringBoot 的全局配置文件 application.properties 或 application.yml 修改端口等也是自动装配
      4. 流程
         1. 使用@EnableAutoConfiguration启用自动装配-默认是true
            1. 实际使用是@SpringBootApplication,包含了自动装配以及其他
               1. @EnableAutoConfiguration：启用 SpringBoot 的自动配置机制
               2. @Configuration：允许在上下文中注册额外的 bean 或导入其他配置类
               3. @ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean
         2. 获取EnableAutoConfiguration注解中的 exclude 和 excludeName进行过滤
         3. 使用SpringFactoriesLoader加载META-INF/spring.factories中的自动配置类
         4. 针对读取到的全部配置类进行过滤和条件判断,满足条件的才保留
10. SpringCloud
    1. SpringCloud是一系列框架的集合。它构建于SpringBoot之上，为常见的分布式系统提供了一整套简单,易于接受的编程模型
    2. eureka----- 微服务治理，服务注册和发现
    3. Ribbon------负载均衡 请求重试
    4. Hystrix----断路器 服务降级 熔断
    5. Openfegin-----hystrix+ribbon的集成 并提供声明式客户端
    6. Hystrix dashboard和turbine-----熔断监控 和熔断显示
    7. zull/gateway----Api网关
    8. config--------.配置中心
    9. spring cloud bus------消息总线 配置刷新
    10. sleuth+zipkin -------链路追踪


## netty
1. Netty是建立在NIO基础之上，Netty在NIO之上又提供了更高层次的抽象
2. 目的-快速开发高性能、高可靠性的网络服务器和客户端程序
3. 优点-提供异步的、事件驱动的网络应用程序框架和工具
4. 提供了内置的常用编解码器
   1. 行编解码器［一行一个请求］
   2. 前缀长度编解码器［前N个字节定义请求的字节长度］
   3. 可重放解码器［记录半包消息的状态］
   4. HTTP编解码器
   5. WebSocket消息编解码器
5. 提供了一些列生命周期回调接口
   1. 当一个完整的请求到达时
   2. 当一个连接关闭时
   3. 当一个连接建立时
   4. 用户都会收到回调事件，然后进行逻辑处理
6. 同时管理多个端口
7. 除了可以处理TCP Socket之外，还可以处理UDP Socket
8. 对ByteBuffer在性能和使用的便捷性上都进行了优化和抽象
9. 应用
   1. Dubbo 的 RPC 框架
   2. 消息中间件 RocketMQ 的消息生产者和消息消费者之间
   3. Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架,使用netty service 

## dubbo
1. 是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案
2. 快速失败-调用失败,抛出异常
3. 安全失败-记录日志,不抛出异常

## gRPC

## groovy
1. 本身就是基于java的语言,语法接近
2. 结尾不用;
3. 不用访问修饰符
4. 提供了一些列断言方法
5. 使用as修饰符定义
6. 方法指定返回内容 

## es

## MongoDB

## zookeeper

## canal
1. 阿里巴巴开源的一款数据库日志增量解析组件
2. 使用Canal可以做到业务代码完全解耦，API完全解耦，可以做到准实时
3. 通过将自身模拟为mysql从库,处理binlog,再同步到其他存储系统中(kafka,es等)
4. ![](https://pic1.imgdb.cn/item/67a72939d0e0a243d4fd0d73.png)
5. 结构
   1. ![](https://pic1.imgdb.cn/item/67a7293ad0e0a243d4fd0d75.png)
   2. ![](https://pic1.imgdb.cn/item/67a7293ad0e0a243d4fd0d76.png)
   3. server代表一个canal实例,对应一个JVM进程
   4. Instance：对应一个数据队列（1个Server对应1个或者多个Instance）
   5. EventParser：数据源接入，模拟Slave协议和Master节点进行交互，协议解析
   6. EventSink：EventParser和EventStore的连接器，对数据进行过滤、加工、归并和分发等处理
   7. EventSore：数据存储
   8. MetaManager：增量订阅和消费信息管理
