# redis

## 基本数据结构
1. string字符串
   1. 动态字符串,是可以修改的字符串,内部结构实现上类似于 Java 的 ArrayList,采用预分配冗余空间的方式来减少内存的频繁分配
   2. 分配方式
      1. 当字符串长度小于1M时,都是加倍扩容
      2. 当字符串长度超过1M后,每次增加1M
      3. 最大长度512M
   3. redis所有数据结构的key都是字符串,只是value的格式不同
   4. 字符串是由多个字节组成,每个字节又是由 8 个 bit 组成,如此便可以将一个字符串看成很多 bit 的组合,这便是 bitmap「位图」数据结构
   5. 如果value的值是一个整数,则可以进行数值加减等操作以及自增,自增是有范围的,最大是Long.Max/signed long/有符号的long,2^63 - 1
2. list列表
   1. 相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组
   2. 底层结构-快速列表 quicklist
      1. 当数据量较少时,使用一块连续的内存空间,此时结构是压缩列表ziplist
      2. 当数据量较多时,改为使用quicklist
      3. quicklist其实是多个ziplist使用指针连接起来双向链表
   3. 时间复杂度
      1. 插入和删除的速度很快,时间复杂度是O(1)
      2. 查询的速度很慢,时间复杂度是O(n)
         1. 对于语句是lindex-相当于 Java 链表的get(int index)方法
         2. 可以负数,相当于倒数开始计数
   4. 当最后一个元素被删除后,内存结构会被回收
   5. 可以被当做异步队列使用,一个线程插入数据,一个线程定时获取数据
   6. 队列-右进左边出
      1. rpush相当于后插入的元素排右边
      2. lpop相当于把队列左侧的元素取出
   7. 栈-右边进右边出
      1. rpush相当于后插入的元素排右边
      2. rpop相当于把队列右侧的元素取出
   8. 特殊函数
      1. lindex
      2. ltrim-相当于截取,生成一个新的链表
3. hash哈希-字典
   1. java中的map是一次性refresh
   2. redis中为了提高性能,不拥堵,采用是渐进式refresh
   3. 优缺点
      1. 优点:可以将同一类型的数据放在一个key内
      2. 缺点:存储的结构消耗要大于字符串,同时只能针对key做过期处理
   4. 支持单个key进行计数
   5. key只能是字符串
4. set集合
   1. 当集合中最后一个元素移除之后，数据结构自动删除，内存被回收
   2. key是唯一的,value是null
5. zset有序集合
   1. 当集合中最后一个元素移除之后，数据结构自动删除，内存被回收
   2. key是唯一的
   3. 每个key关联一个double类型的分数,从小到大排序
   4. 内部的排序通过跳跃列表实现
6. 以上都是容器类型的数据结构,支持create if not exists与drop if no elements
7. 分布式锁-redis2.8开始支持setnx和expire做为一个原子操作
8. 位图-Bitmaps
   1. 并不是实际的数据结构,而是在字符串类型上定义的面向位的操作
   2. String的最大长度是512M,那么位图支持设置成2^32个不同字节
   3. 最大的优势是极其节约空间,如果使用字符会有大量的字节空间浪费,并不是绝对,而是要根据实际业务来
9. HyperLogLog-计数
    1. 面对海量的数据,如果不是要求非常精确的计数,可以使用,因为HyperLogLog只占用12kb的空间,而zet会随着数据量的增多而线性增长
    2. 标准误差是 0.81%
    3. 在计数较小时,使用稀疏矩阵
    4. 当计数较多时,会一次性转为稠密矩阵,但也只占用12kb
10. 布隆过滤器-标记是否存在
    1. redis4.0开始支持
    2. 不是为了存储数据,而是为了标记数据,判断是否存在
    3. 只要参数设置的合理,精确度会相对很高,只会有小概率的误判
    4. 数据结构上是一个大型的位数组和几个分布得比较平均的hash
    5. 添加流程
       1. 会使用多个hash对key进行hash计算,得到多个整数索引值
       2. 每个整数索引值对位数组长度进行取模,得到一个位置
       3. 再在位数组上对这些位置标记为1
    6. 只要在一个位置上为0,则认为这个值不存在
    7. 如果都是1,并不是这个值就一定存在,位数组越稀疏,概率越大
    8. NoSql中大量使用布隆过滤器
       1. 可以降低数据库中的I/O使用量
       2. 可以先在内存中使用布隆过滤器过滤掉不存在的key,再使用磁盘判断
11. 限流
    1. 简单限流-使用zset,每次只获取固定source值内的元素
    2. 漏斗算法-redis4.0支持redis-cell
12. 地理位置GEOHash模块
    1.  将二维的经纬度映射到一个一维的整数,这个整数可以还原为经纬度
    2.  整数越长,说明精度越高
    3.  实际存储结构是一个zset,value是地点,source是52位的一维的整数
    4.  支持计算2点的距离,有一定的精度损失
    5.  支持计算附件的坐标
    6.  数据量大时,需要根据国家和省份进行拆分
13. 查找方法
    1.  keys,没有offset与limit,时间复杂度O(n),会阻塞其他线程
    2.  scan,时间复杂度也是O(n),但是是通过游标分步进行的,不会阻塞线程
        1.  结果集可能重复,需要客户端去重
        2.  遍历过程中数据变更,是否会被遍历到不确定
        3.  返回数据为空,不一定代表遍历结束,还是要取决于游标值是否为0
        4.  高位进位加法来遍历
            1.  避免字典的扩容和缩容时槽位的遍历重复和遗漏
            2.  从左向右遍历
            3.  rehash后,扩容和缩容无需关心左边的槽
            4.  redis采用渐进式 rehash,会同时保留新老2个,在定时任务和后续hash中逐步迁移
    3.  字典
        1.  redis中所有的key都是存在一维数组和二维链表中,和java中的hashmap一样

## 原理
1. 线程 IO 模型
   1. 单线程
      1. 单线程模型,但在redis4.0开始引入了多线程,但核心逻辑还是单线程
      2. 大部分操作都在内存中
      3. 事件轮询-多路复用机制-类似java的NIO-可以同时处理多个客户端的连接
      4. 非阻塞I/O-读和写都不阻塞
      5. 使用单线程的原因
         1. 开发和维护成本低-多线程需要额外维护并发控制
         2. 单线程也可以并发处理多个连接
            1. 多路复用机制-一个线程也可以处理多个不同的客户端连接
            2. 通过使用select，epoll或kqueue等多路复用API来检测不同的连接的读写请求事件
            3. 能降低系统开销,不用创建大量的线程来监听
         3. redis的瓶颈不是CPU-普通配置下,1秒也能处理10w个请求
      6. redis4.0引入多线程,处理大键值的删除,同时多线程非阻塞的释放内存空间也可以减少对主线程的阻塞.一开始删除的只是元数据,真实的删除还是多线程
      7. redis6.0引入多线程,处理网络的序列化与反序列化,降低网络I/O消耗
   2. 指令队列-每个客户端连接会关联一个指令队列,客户端的指令加入到指令队列中,先到先执行
   3. 响应队列-每个客户端连接会关联一个响应队列,处理的结果放在响应队列中,如果队列为空,则释放写操作
   4. 定时任务
      1. 有一个最小堆数据结构,最快要执行的任务放在最上面
      2. 同时会记录下一个任务的timeout时间
      3. 在这个timeout时间还没到时,可以处于空闲时间
2. 通信协议
   1. RESP-Redis Serialization Protocol
   2. 是一种简单的格式,包含大量的换行与空格
   3. 实际是一种浪费大量文本的协议,但优点是逻辑简单,解析速度快
3. 持久化
   1. 快照-RDB-通过子线程处理,使用操作系统的多线程COW机制-COPY-ON-WRITE
   2. AOF
      1. 类似于mysql的binlog
      2. 记录的是顺序指令序列化产物
      3. redis是先操作数据,再记录到磁盘
      4. 会使用重写进行AOF瘦身,根据当前的内存数据重写AOF日志
      5. 使用系统的fsync函数
   3. 可以使用从节点进行持久化
   4. 从redis 4.0 开始支持混合形式-快照+增量的AOF
4. 管道-通过调整管道中的指令顺序来降低I/O-本质是批量处理
5. 事务
   1. 不是严格意义上的原子性,中间执行错了,还是会继续执行
   2. 只是通过单线程执行保证了隔离线
   3. 会有一个事务队列,在收到exec命令后才一起执行
   4. watch机制
      1. 可以使用分布式锁来解决并发,但本质是一个悲观锁
      2. redis提供了一种乐观锁的机制
      3. watch命令会在事务执行前关注1-2个变量
      4. 如果事务执行过程中,watch的变量发了变化,则事务返回null,此时让客户端进行重试
6. Pub/Sub-发布者订阅者模型
   1. 消费者重新上线后历史消息收不到-没有持久化
   2. redis5.0开始提供了stream机制,支持了持久化消息队列,Pub/Sub已经被淘汰
7. 节省内存存储空间
   1. 小对象压缩存储-ziplist-使用紧凑型存储-会升级为hashtable
   2. 存储界限-当元素不断增加时,会升级为标准存储
   3. 回收机制
      1. 元素被删除后,不会马上回收,回收通过操作系统在页维度进行
      2. 只要这个页上还有其他key,则不会回收,但可以重用空间
   4. 三方内存管理库-redis本身未实现-使用第三方内存分配库-Redis默认使用了jemalloc(Facebook)
8. 主从同步
   1. CAP-分布式理论
      1. C-一致性
      2. A-可用性
      3. P-分区容错性
   2. redis使用的是最终一致,主从节点之间异步同步,从节点追赶主节点
   3. 主从网络中断,主节点还是可用,满足可用性
   4. redis同步支持主从同步与从从同步
   5. 增量同步
      1. 主节点将影响内存的指令同步到buffer中,再异步同步给从节点
      2. 从节点完成指令后通知主节点进度偏移量
      3. buffer空间有限,是一个环形结构,当用完后,会再覆盖首节点
   6. 快照同步
      1. 非常耗费资源
      2. 使用bgsave将全部数据同步到磁盘,再同步给从节点
      3. 从节点清除全部内容后,根据快照文件进行全量加载
      4. 从节点同步完成后,通知主节点进行增量同步
      5. 当快照时间太长或buff空间太小,会导致同步失败,则重新开始快照同步
      6. 无盘复制-主节点之间使用内存进行同步,不经过磁盘
      7. wait指令-让异步复制变成同步复制
9. 哨兵机制-Sentinel
   1.  最小配置是一主一从
   2.  哨兵机制是一个管理工具,支持主从节点健康情况监控,通知,故障转移
       1.  主从存活监控
       2.  主从运行情况监控
       3.  故障转移
       4.  主从切换
   3.  哨兵
       1.  当主节点挂了,从从节点中选取一个生成新的主节点
       2.  客户端连接时,从哨兵获取主从节点信息
       3.  当主节点崩溃时,从哨兵获取新的主节点
       4.  哨兵仅仅解决了高可用,主从节点的转移问题,但无法解决扩容问题,还是要使用redis cluster集群模型
   4.  Ping-每个哨兵默认1秒1次向主从节点和其他哨兵节点执行一次ping命令,通过节点的回复,来判断是否在线
   5.  主观下线-适用所有主从节点,超过30秒没有回复,则认为是主观下线
   6.  客观下线-只适用所有主节点,当没有回复时,会向其他哨兵询问该节点状态,如果超过一定的哨兵认为没有回复,则认为客观下线
10. 集群方案
    1.  codis
        1.  无状态的,是一个代理转发中间件
        2.  将所有的key分配到1024个槽(slot)中
        3.  每次一个key进入,需要进行hash计算,再对1024进行取余计算,得到分配到哪个槽中
        4.  使用zookeeper或etcd存储key与槽的关系,当槽信息发生变更时,代理从zk中重新同步
        5.  扩容-如果key命中所在的槽在扩容中,则强制将这个key迁移到其他槽中
        6.  优点-分布式问题交给zookeeper或etcd处理
        7.  缺点
            1.  不支持事务-key分布在不同的节点中
            2.  rename动作不支持-因为是使用key进行分发
            3.  单个key对应的value不能太大
            4.  增加了代理层,网络开销加大
            5.  需要额外维护分布式中间件
    2.  redis cluster
        1.  去中心化的
        2.  有16384个槽,比codis更精细
        3.  每个节点负责一部分的槽,槽的信息在节点上,无需zk
        4.  客户端需要缓存槽位信息,因为没有代理层
        5.  定位算法和codis类型,但需要指定槽
        6.  迁移-以槽位单位,会阻塞线程,所有key不能太多
        7.  节点故障
            1.  支持设置超时时间确定节点故障
            2.  使用Gossip协议来广播自身状态和确认节点状态
            3.  当某个节点发现认定该节点失联的数量超过设置,则标记该节点为下线状态,并进行广播
            4.  对失联节点进行主从切换

## 扩展
1. stream
   1. 支持多播的持久化消息队列,redis5.0开始提供
   2. 支持定义多个消费组,互相独立
   3. 一个消费组下的多个消费者,互相竞争
   4. 支持独立消费,不定义消费组
   5. 支持定长stream
   6. 客户端完成消费后,会发送xack给服务端,将该消息从PEL中移除
   7. 如果没有ack,则会导致PEL的内存不断变大
   8. PEL如果避免消息丢失,PEL中存储了已经发送出去的消息ID
   9. 原生不支持partition,可以建多个stream
2. info-可以查询各类信息,连接情况,内存情况,持久化信息,CPU,集群等信息
3. readLock
   1. 为了解决在哨兵模式下,主节点加锁成功后崩溃,从节点会被重复加锁
   2. 半数以上的从节点加锁成功,才认为是加锁成功
   3. 没有主从关系,会有额外的运维成本
4. 过期策略
   1. 所有设置了过期时间的key放在一个单独的字典内
   2. 方式
      1. 定时遍历
         1. 默认每1秒进行10次扫描
         2. 每次扫描的时间上限默认不超过25ms
         3. 为了避免批量过期导致的压力,过期时间上应该加一个随机值
         4. 贪心策略
            1. 每次从过期字典中随机捞出20个key
            2. 如果其中有过期了的,则进行删除
            3. 如果有超过1/4的key过期,则重复步骤
      2. 惰性策略-访问某个key时,过期时间到了,则删除
   3. 从库并不会定期扫描,而是使用主库的del语句
5. LRU
   1. 可以设置redis的最大内存
   2. 超出最大内存后的执行策略
      1. noeviction-不再提供写请求,只提供读请求
      2. volatile-xxx 策略只会针对带过期时间的 key 进行淘汰
         1. volatile-lru-针对最少使用的key淘汰
         2. volatile-ttl-越小的ttl,越早淘汰
         3. volatile-random-过期的key随机淘汰
      3. allkeys-xxx 策略会对所有的 key 进行淘汰
         1. allkeys-lru-针对最少使用的key淘汰
         2. allkeys-random-key随机淘汰
      4. redis采用的是近似LRU
         1. 懒惰处理-当执行写操作时,如果内存超过了max限制,则执行一次LRU淘汰
         2. 节省存储空间
         3. 贪心策略-随机取出5个(可以配置)进行淘汰,如果淘汰后还超过最大内存限制,则再进行一次采样
6. 保护 Redis
   1. 端口修改
   2. ssl代理
   3. 高危操作命令改为别名
   4. 禁止lua脚本由用户输入
7. lua 脚本-redis提供了lua脚本执行,来达到原子性操作
8. 内置的命令行工具 redis-cli
   1. 扫描大key
   2. 采样
   3. 诊断服务器时延
   4. 远程 rdb 备份

## 源码
1. 字符串
   1. SDS-Simple Dynamic String-带长度信息的字节数组
   2. 刚开始创建时len和capacity一样长
   3. 最大长度512M
   4. 小于1M时,每次翻倍扩容.大于1M后,每次增加1M
   5. 存储方式
      1. empStr-RedisObject对象头和SDS连续存储
      2. raw-长度超过44后,分开存储
2. 字典-hash
   1. 渐进式rehash
   2. 扩容条件
      1. 当hash表中元素个数等于一维数组长度时,翻倍扩容
      2. 当进行bgsave动作时,暂时不扩容.除非达到5倍长度,则强制扩容
   3. 缩容-占用的元素小于10%
3. 压缩列表-ziplist
   1. 当zset和hash中的元素较少时-使用压缩列表
   2. 紧凑存储,数据之间没有其他冗余空间
   3. 支持双向遍历
      1. 结构中有存储整个结构的长度,所有支持从末尾开始遍历
      2. 每个entery中有存储 prevlen 字段,表示前一个entry的长度
   4. 增加元素
      1. 由于是紧凑存储-所以增加新元素需要扩容
      2. 可能需要分配新的空间,则从旧结构一次性复制到新结构
      3. 也可能在原地址上扩展,则无需复制
      4. 如果ziplist占用的空间太大,则开辟新空间和复制成本太大,不适合存大字符串,存的元素也不能太多
   5. 级联更新-由于每个entery都存了 prevlen 字段,那么元素更新,整个列表会更新
   6. IntSet
      1. 小整数集合-当set里的数据都是整数且元素较少时,会使用 IntSet 结果存储数据
      2. 当放入了非整数,则结构会调整为hash
4. 快速列表-quicklist
   1. 早期版本的redis存储list时,数据少用ziplist,数据多使用linklist
   2. 后期改为,数据少用ziplist,数据多使用快速列表quicklist(ziplist+linklist)
   3. 将linklist分为多段,每段包含一个ziplist,多个ziplist之间使用双向指针连接起来
   4. 为了节约空间,使用LZF算法压缩,默认深度为0,则表示不压缩
5. 跳跃列表-skiplist
   1. zset内部的排序功能通过跳跃列表实现
   2. zset内部是一个复合结构-一个hash字典+跳跃列表
      1. hash存储value和source的关系
      2. 跳跃列表实现排序以及圈选source来获取部分value的功能
   3. 跳跃列表包含多个kv结构,之间使用双向指针连接在一起,有序排列,从小到大
   4. 跳跃表一共有64层
   5. 搜索路径-从最高层开始向下,直到找到符合最小的
   6. 随机层数-官方的源码晋级概率只有25%-比较扁平-层高比较低-在单个层上遍历的次数会相对多一些
   7. 更新过程
      1. 先删除元素,再加入元素,需要2次路径搜索
      2. 如果source变化较小,则可以直接更新
   8. 当source一样时,会比较value
6. 紧凑列表-listpack
   1. redis5.0引入的结构
   2. 目的是为了优化ziplist,存储空间节省,结构更加精简
   3. 目前只在stream结构中使用
   4. 消灭了ziplist的级联更新,元素和元素之间独立
   5. 反向遍历更加简单,不用维护最后一个元素的位置,不过依赖元素的长度
7. 基数树-Rax
   1. 有序字典树,根据key进行排序,支持快速定位,插入和删除
   2. hash不支持排序,zset是使用source排序
8. LFU vs LRU
   1. Redis 4.0 里引入了一个新的淘汰策略
   2. Least Frequently Used-按照最近的访问频率进行淘汰,比LRU更精准放映一个key的访问热度
   3. redis所有的对象头都有一个24bit的字段,其中存储了对象的热度
   4. LRU存的是时间戳-计算出对象的空闲时间
   5. LFU内容
      1. logc(logistic counter)-访问频次
      2. ldt(last decrement time)-上一次 logc 的更新时间,分钟级,精度不高-不在对象被访问时更新,而是在淘汰时
   6. redis会缓存系统时间戳
      1. 因为频繁获取系统时间戳消耗太大
      2. 原子操作,但是异步进行,不影响主线程
9. 懒惰删除-使用异步线程对已删除的节点进行内存回收
10. 字典遍历
    1.  一边遍历一边修改-遇到过期的key则淘汰
    2.  rehashStep-旧的hashtable迁移到新的hashtable
    3.  迭代器
        1.  安全-禁用hashtable
            1.  不会出现重复元素
            2.  给元素打上标记-rehashStep就不会进行
            3.  使用安全迭代的命令-bgsave,keys,bgaofrewrite
        2.  不安全-不禁用hashtable-只读命令
11. HyperLogLog
    1.  近似统计海量去重元素数量的算法
    2.  内部维护了16384个桶,来统计各个桶内的元素数量

## 面试题
1. 有哪些数据类型
   1. 基础数据类型 String list hash set zset
   2. HyperLogLog 地理GEO 布隆过滤器
2. Redis分布式锁
   1. 通过setnx expire完成原子性动作
   2. 或者lua脚本
3. 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来
   1. 使用keys命令,支持指定的key查询,但会阻塞主检查
   2. 使用scan,通过游标来,但会有一定的数据重复,需要去重,不会阻塞主检查
4. Redis做异步队列
   1. 使用list结果,rpush生产消息,lpop消费消息.当lpop时可能会无数据,需要sleep一会
   2. 使用pub/sub消息订阅模式,但消费者下线后重新上线时无法获取中间丢失的消息,使用kafka
   3. 使用stream机制,支持持久化
5. Redis如何实现延时队列
   1. 使用zset,source为时间戳
   2. 消费者根据source筛选指定时间段获取数据
6. 大量的key同时过期
   1. 设置ttl时增加一定的随机时间
7. Redis如何做持久化的
   1. 全量用bgsave,增量用aof.bgsave比较耗时,系统重启时,会先用aof,aof没有则用rbd文件
   2. 定期瘦身,重写aof,支持混合形式
   3. 机器突然掉电,取决于sync配置,默认是1秒,那么最多是丢失1秒的数据
8. bgsave的原理是什么
   1. fock-唤起子线程
   2. cow-copy on write
9.  Pipeline有什么好处，为什么要用pipeline
    1.  多个请求的I/O返回放在一次动作中,节约开销
10. Redis的同步机制
    1.  主从同步与从从同步
    2.  快照同步:第一次同步时主节点使用bgsave,从节点清除自身数据后开始同步.主节点并将后续动作记录在buffer中,从节点同步完成后通知主节点,消费从节点的增量同步
    3.  增量同步:主节点将影响数据的指令记录到buffer中,从节点消费,完成后通知主节点自身的消费偏移量
11. Redis集群
    1.  codis
        1.  代理中间件
        2.  将key分配在1024个槽中
        3.  每个key会进行hash,再对1024进行取余,得到分配在哪个槽中
        4.  需要zookeeper或ectd等中间件完成分布式动作
        5.  key所在的槽在扩容,则强制迁移key
        6.  缺点:增加了网络开销
    2. redis cluster
       1. 有1w多个槽,比codis更加打散
       2. 分配算法和codis类似
       3. 每个节点上存储了对应的槽信息
       4. 迁移以槽位单位,会阻塞,所以key不能太多
       5. 客户端需要缓存槽的分布信息
       6. 无需维护zk等
       7. 使用Gossip协议来广播自身状态和确认节点状态
12. 雪崩
    1.  redis宕机,请求都打到mysql上
    2.  事前
        1.  使用哨兵机制,自动进行故障转移
        2.  主从集群
    3.  事中-网关限流,降级,增加pod本地缓存,逐步等待redis恢复
    4.  事后-redis开启持久化,直接从磁盘恢复数据
13. 穿透
    1.  突然出现大量没有在redis中数据
    2.  限制ip
    3.  部分数据进行预热,加入到缓存中,并设置ttl
14. 击穿
    1.  某个缓存热度非常高,ttl时间到了,直接打到mysql
    2.  如果数据基本不变,设置为不过期
    3.  如果数据变化少,则可以加一道分布式锁,出现击穿则重新加入缓存
    4.  如果数据变化多,则可以单独设置定时任务更新数据或延迟过期时间
